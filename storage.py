import json
import os
from dotenv import load_dotenv
from typing import Mapping
import logging
from datetime import datetime
from asynctinydb import TinyDB, Query, BaseID, BaseDocument, JSONStorage
from asynctinydb.table import Table

__all__ = ('DiscordID', 'UserDocument', 'Database')

load_dotenv()
LOCAL_STORAGE = os.environ["LOCAL_STORAGE"]
RECORD = Query()


""" Using Discord ID as BaseID for all database tables """
class DiscordID(int, BaseID):
    """ Discord ID follows Twitter's snowflake format, supporting up to 64 bits unsigned integers. """
    __init__ = int.__init__

    def __str__(self) -> str:
        return int.__str__(self)

    def __hash__(self) -> int:
        return int.__hash__(self)

    @classmethod
    def next_id(cls, table: Table, keys):
        """
        We don't generate Discord ID.
        """
        raise NotImplementedError()

    @classmethod
    def mark_existed(cls, table: Table, new_id):
        """
        Marks an ID as existing; the same ID shouldn't be generated by next_id.
        """
        ...

    @classmethod
    def clear_cache(cls, table: Table):
        """
        No point to cache Discord IDs if we don't implement next_id()
        """
        ...


""" Type hints for UserDocument with a fixed set of keys """
"""
from typing import NotRequired, ReadOnly, TypedDict

class UserRecord(TypedDict):
    nutaku_id: NotRequired[int]
    user_id: NotRequired[int]
    guild_id: NotRequired[int]
    name: NotRequired[str]
    premium: bool
    bot: ReadOnly[bool]
    session_id: NotRequired[str]
    socket_token: NotRequired[str]
    create_time: ReadOnly[int]
    last_update: int
    last_session_update: NotRequired[int]
    next_update: NotRequired[int]
"""

""" Design User Document stored in UserTable """
class UserDocument(dict, BaseDocument):
    """
    A document stored in the user table.

    This class provides a way to access both a document's content and
    its ID using ``doc.doc_id``.
    """
    def __init__(self, value: Mapping, doc_id: DiscordID):
        #TODO: replace Mapping with UserRecord
        super().__init__(value)
        self.doc_id = doc_id

    def __hash__(self) -> int:
        return object.__hash__(self)

    @property
    def doc_id(self) -> DiscordID:
        return self._doc_id

    @doc_id.setter
    def doc_id(self, value: DiscordID):
        self._doc_id = value

    def __repr__(self):
        pp = json.dumps(self, indent=2, ensure_ascii=False)
        return f"Document(\n  doc_id={self.doc_id} \n  doc={pp})"

    def get_discord_user_id(self) -> DiscordID:
        return self._doc_id

    def is_premium(self) -> bool:
        return self['premium']

    def is_bot(self) -> bool:
        return self['bot']

    def get_nutaku_id(self) -> int | None:
        return self['nutaku_id']

    def get_user_id(self) -> int | None:
        return self['user_id']

    def get_prefix(self) -> int | None:
        if self['user_id']:
            return int(str(self['user_id'])[:3])
        else:
            None

    def get_guild_id(self) -> int | None:
        return self['guild_id']

    def get_name(self) -> str | None:
        return self['name']

    def get_session_id(self) -> str | None:
        return self['session_id']

    def get_socket_token(self) -> str | None:
        return self['socket_token']

    def get_create_timestamp(self) -> int:
        return self['create_time']

    def get_last_update_timestamps(self) -> int:
        return self['last_update']

    def get_next_update_timestamp(self) -> int | None:
        return self['next_update']

    def get_last_session_update_timestamp(self) -> int | None:
        return self['last_session_update']


""" Asynchronous TinyDB with CRUD implementation """
class Database(TinyDB):
    default_table_name = "_default"

    def __init__(self, filepath=LOCAL_STORAGE):
        #db = TinyDB(LOCAL_STORAGE, no_dbcache=True)
        #db.isolevel = 2
        super().__init__(filepath, isolevel=2, no_dbcache=True)
        self.storage_type = JSONStorage(filepath)
        self.user = self.UserTable(self.storage_type)

    class UserTable(Table):
        _logger = logging.getLogger("usertable")

        def __init__(self, storage):
            #TODO: change default isolevel, refers to https://github.com/VermiIIi0n/async-tinydb/issues/12
            super().__init__(storage, "user", no_dbcache=True, document_id_class=DiscordID, document_class=UserDocument)

        async def create(self, key: DiscordID, user_id: int, nutaku_id: int = None, premium=False, bot=False):
            new_ts = self._get_current_timestamp()
            try:
                assert len(str(user_id)) == 13
                user = { 'nutaku_id': nutaku_id, 'user_id': user_id, 'guild_id': None, 'name': None, 'premium': premium, 'bot': bot, 'session_id': None, 'socket_token': None, 'create_time': new_ts, 'last_update': new_ts, 'last_session_update': 0, 'next_update': 0 }
                document = UserDocument(user, key)
                await self.insert(document)
            except Exception as e:
                self._logger.exception(f"{e}")
    
        async def get_user(self, key: DiscordID) -> UserDocument:
            user = await self.get(doc_id=key)
            return UserDocument(user, user.doc_id)

        async def get_all_users(self) -> list[UserDocument]:
            users = await self.all()
            return list(UserDocument(user, user.doc_id) for user in users)

        async def get_next_update_users(self) -> list[UserDocument]:
            new_ts = self._get_current_timestamp()
            match_users = await self.search(RECORD.next_update <= new_ts)
            return list(UserDocument(user, user.doc_id) for user in match_users)

        async def update_user(self, key: DiscordID, user_id: int, name: str, session_id: str, socket_token: str, server_time: int) -> None:
            new_ts = self._get_current_timestamp()
            await self.update({ 'user_id': user_id, 'name': name, 'session_id': session_id, 'socket_token': socket_token, 'last_update': new_ts, 'last_session_update': server_time }, doc_ids=[key])

        async def update_nutaku_id(self, key: DiscordID, nutaku_id: int) -> None:
            new_ts = self._get_current_timestamp()
            await self.update({ 'nutaku_id': nutaku_id, 'last_update': new_ts }, doc_ids=[key])

        async def update_user_id(self, key: DiscordID, user_id: int) -> None:
            new_ts = self._get_current_timestamp()
            await self.update({ 'user_id': user_id, 'last_update': new_ts }, doc_ids=[key])

        async def update_guild_id(self, key: DiscordID, guild_id: int) -> None:
            new_ts = self._get_current_timestamp()
            await self.update({ 'guild_id': guild_id, 'last_update': new_ts }, doc_ids=[key])

        async def update_session_id(self, key: DiscordID, session_id: str) -> None:
            new_ts = self._get_current_timestamp()
            await self.update({ 'session_id': session_id, 'last_update': new_ts, 'last_session_update': new_ts }, doc_ids=[key])

        async def set_next_update_timestamp(self, key: DiscordID, next_ts: int) -> None:
            new_ts = self._get_current_timestamp()
            await self.update({ 'last_update': new_ts, 'next_update': next_ts }, doc_ids=[key])

        async def verify_socket_token(self, key: DiscordID, since_sec=21600) -> bool:
            user_info = await self.get_user(key)
            new_ts = self._get_current_timestamp()
            return since_sec > (new_ts - user_info['last_session_update'])

        async def remove_user(self, key: DiscordID):
            await self.remove(doc_id=key)

        async def remove_user_by_user_id(self, user_id: int):
            await self.remove(RECORD.user_id == user_id)

        def _get_current_timestamp(self) -> int:
            return int(datetime.now().timestamp())
